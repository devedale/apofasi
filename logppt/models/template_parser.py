"""
Template-based log parser that uses extracted templates to parse new log lines.

This module loads templates generated by Ollama and uses them to parse new log lines,
extracting dynamic parameters and matching them against the template structure.
"""

import json
import re
import os
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path


class TemplateLogParser:
    """
    Parser that uses extracted templates to parse new log lines.
    
    This parser loads templates generated by Ollama and uses them to:
    1. Match new log lines against known templates
    2. Extract dynamic parameters
    3. Structure the parsed data
    """
    
    def __init__(self, templates_file: str = None):
        """
        Initialize the template parser.
        
        Args:
            templates_file: Path to the JSON file containing extracted templates
        """
        self.templates_file = templates_file or "outputs/ollama_parsing_results.json"
        self.templates = {}
        self.template_patterns = {}
        
        if os.path.exists(self.templates_file):
            self.load_templates()
    
    def load_templates(self) -> bool:
        """
        Load templates from the JSON file.
        
        Returns:
            True if templates loaded successfully, False otherwise
        """
        try:
            with open(self.templates_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Extract templates and organize them by type
            for item in data:
                if item.get("success") and "template" in item:
                    original_log = item["original_log"]
                    template = item["template"]
                    
                    # Determine log type based on content
                    log_type = self._classify_log_type(original_log)
                    
                    # Store template with metadata
                    self.templates[log_type] = {
                        "original_log": original_log,
                        "template": template,
                        "pattern": self._create_pattern(template),
                        "metadata": {
                            "model_used": item.get("model_used"),
                            "response_time": item.get("response_time"),
                            "tokens_used": item.get("tokens_used")
                        }
                    }
            
            print(f"✅ Caricati {len(self.templates)} template per il parsing")
            return True
            
        except Exception as e:
            print(f"❌ Errore nel caricare i template: {e}")
            return False
    
    def _classify_log_type(self, log_line: str) -> str:
        """
        Classify log type based on content patterns.
        
        Args:
            log_line: The log line to classify
            
        Returns:
            String identifying the log type
        """
        # Android logs - more flexible pattern matching
        if any(keyword in log_line for keyword in [
            "WindowManager", "PowerManagerService", "ActivityManager", 
            "PackageManager", "SystemUI", "AndroidRuntime", "dalvikvm",
            "ActivityThread", "Binder", "Handler", "Looper"
        ]):
            return "Android"
        elif "HTTP" in log_line and ("GET" in log_line or "POST" in log_line):
            return "Apache"
        elif "kernel:" in log_line or "sshd" in log_line:
            return "Linux"
        elif "Event ID:" in log_line:
            return "Windows"
        elif "docker:" in log_line:
            return "Docker"
        elif "kubelet:" in log_line:
            return "Kubernetes"
        else:
            return "Unknown"
    
    def _create_pattern(self, template: str) -> str:
        """
        Create a regex pattern from the template.
        
        Args:
            template: The template string
            
        Returns:
            Regex pattern string
        """
        # Handle different template formats
        if "```markdown" in template:
            # JSON template - extract the structure
            return self._extract_json_pattern(template)
        elif "%{" in template:
            # Placeholder template - convert to regex
            return self._convert_placeholder_to_regex(template)
        else:
            # Simple template - use as is
            return re.escape(template)
    
    def _extract_json_pattern(self, template: str) -> str:
        """
        Extract regex pattern from JSON template.
        
        Args:
            template: JSON template string
            
        Returns:
            Regex pattern string
        """
        # Extract the JSON content from markdown
        json_match = re.search(r'```markdown\s*\n(.*?)\n```', template, re.DOTALL)
        if json_match:
            json_content = json_match.group(1)
            # Convert JSON structure to regex pattern
            pattern = self._json_to_regex_pattern(json_content)
            return pattern
        
        return re.escape(template)
    
    def _json_to_regex_pattern(self, json_content: str) -> str:
        """
        Convert JSON template to regex pattern.
        
        Args:
            json_content: JSON content string
            
        Returns:
            Regex pattern string
        """
        # This is a simplified conversion - in practice you'd want more sophisticated parsing
        pattern = json_content
        
        # Replace common patterns with simple regex
        pattern = re.sub(r'"\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}"', r'([0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\\.[0-9]{3})', pattern)
        pattern = re.sub(r'"\d+"', r'([0-9]+)', pattern)
        pattern = re.sub(r'"[^"]*"', r'([^"]*)', pattern)
        
        return pattern
    
    def _convert_placeholder_to_regex(self, template: str) -> str:
        """
        Convert placeholder template to regex pattern.
        
        Args:
            template: Template with placeholders
            
        Returns:
            Regex pattern string
        """
        # Convert %{VARIABLE} placeholders to regex groups
        pattern = template
        
        # Replace placeholders with appropriate regex patterns
        # Use simple character classes to avoid escape issues
        replacements = {
            r'%{PROTOCOL}': r'([a-zA-Z]+)',
            r'%{HOST}': r'([a-zA-Z0-9.-]+)',
            r'%{PORT}': r'([0-9]+)',
            r'%{TIMESTAMP}': r'(\[.*?\])',
            r'%{METHOD}': r'([A-Z]+)',
            r'%{HTTP_VERSION}': r'([0-9]+\\.[0-9]+)',
            r'%{PATH}': r'([^"]+)',
            r'%{USER_AGENT}': r'([^"]*)',
            r'%{PROCESS_ID}': r'([0-9]+)',
            r'%{MODULE_NAME}': r'([a-zA-Z_]+)',
            r'%{FUNCTION_NAME}': r'([a-zA-Z0-9_+]+)',
            r'%{LINE_NUMBER}': r'([0-9]+)'
        }
        
        for placeholder, regex in replacements.items():
            pattern = pattern.replace(placeholder, regex)
        
        # For simple templates, just escape special characters
        # Don't do complex regex conversion that might break
        return re.escape(pattern)
    
    def parse_log(self, log_line: str) -> Dict[str, Any]:
        """
        Parse a log line using the loaded templates.
        
        Args:
            log_line: The log line to parse
            
        Returns:
            Dictionary containing parsing results
        """
        # Classify the log type
        log_type = self._classify_log_type(log_line)
        
        if log_type not in self.templates:
            return {
                "success": False,
                "error": f"Template non trovato per tipo: {log_type}",
                "log_type": log_type,
                "original_log": log_line
            }
        
        template_info = self.templates[log_type]
        pattern = template_info["pattern"]
        
        try:
            # Try to match the log against the template pattern
            match = re.match(pattern, log_line)
            
            if match:
                # Extract parameters from the match
                params = self._extract_parameters(log_line, log_type, template_info)
                
                return {
                    "success": True,
                    "log_type": log_type,
                    "original_log": log_line,
                    "template_used": template_info["template"],
                    "parameters": params,
                    "metadata": template_info["metadata"]
                }
            else:
                return {
                    "success": False,
                    "error": "Log non corrisponde al template",
                    "log_type": log_type,
                    "original_log": log_line,
                    "template_used": template_info["template"],
                    "pattern": pattern
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": f"Errore nel parsing: {e}",
                "log_type": log_type,
                "original_log": log_line
            }
    
    def _extract_parameters(self, log_line: str, log_type: str, template_info: Dict) -> Dict[str, Any]:
        """
        Extract parameters from a log line based on the template.
        
        Args:
            log_line: The log line to parse
            log_type: Type of the log
            template_info: Template information
            
        Returns:
            Dictionary of extracted parameters
        """
        params = {}
        
        if log_type == "Android":
            # Extract Android-specific parameters
            timestamp_match = re.search(r'(\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})', log_line)
            if timestamp_match:
                params["timestamp"] = timestamp_match.group(1)
            
            pid_match = re.search(r'(\d{4,5})', log_line)
            if pid_match:
                params["pid"] = pid_match.group(1)
            
            component_match = re.search(r'([A-Z][a-zA-Z]+):', log_line)
            if component_match:
                params["component"] = component_match.group(1)
        
        elif log_type == "Apache":
            # Extract Apache-specific parameters
            ip_match = re.search(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', log_line)
            if ip_match:
                params["ip"] = ip_match.group(1)
            
            timestamp_match = re.search(r'\[(.*?)\]', log_line)
            if timestamp_match:
                params["timestamp"] = timestamp_match.group(1)
            
            method_match = re.search(r'"(\w+) ([^"]+) HTTP/(\d+\.\d+)"', log_line)
            if method_match:
                params["method"] = method_match.group(1)
                params["path"] = method_match.group(2)
                params["http_version"] = method_match.group(3)
            
            status_match = re.search(r'" (\d{3}) (\d+)', log_line)
            if status_match:
                params["status_code"] = status_match.group(1)
                params["bytes"] = status_match.group(2)
        
        elif log_type == "Linux":
            # Extract Linux-specific parameters
            timestamp_match = re.search(r'(\w+ \d+ \d{2}:\d{2}:\d{2})', log_line)
            if timestamp_match:
                params["timestamp"] = timestamp_match.group(1)
            
            host_match = re.search(r'(\w+-server)', log_line)
            if host_match:
                params["hostname"] = host_match.group(1)
            
            kernel_match = re.search(r'kernel: \[(\d+\.\d+)\]', log_line)
            if kernel_match:
                params["kernel_timestamp"] = kernel_match.group(1)
        
        return params
    
    def parse_logs_batch(self, log_lines: List[str]) -> List[Dict[str, Any]]:
        """
        Parse multiple log lines in batch.
        
        Args:
            log_lines: List of log lines to parse
            
        Returns:
            List of parsing results
        """
        results = []
        
        for i, log_line in enumerate(log_lines):
            print(f"Parsing log {i+1}/{len(log_lines)}...")
            result = self.parse_log(log_line.strip())
            results.append(result)
        
        return results
    
    def save_parsing_results(self, results: List[Dict[str, Any]], output_file: str) -> bool:
        """
        Save parsing results to a file.
        
        Args:
            results: List of parsing results
            output_file: Path to output file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Errore nel salvare i risultati: {e}")
            return False
    
    def get_template_summary(self) -> Dict[str, Any]:
        """
        Get a summary of loaded templates.
        
        Returns:
            Dictionary containing template summary
        """
        summary = {
            "total_templates": len(self.templates),
            "template_types": list(self.templates.keys()),
            "templates": {}
        }
        
        for log_type, template_info in self.templates.items():
            summary["templates"][log_type] = {
                "has_pattern": bool(template_info.get("pattern")),
                "metadata": template_info.get("metadata", {})
            }
        
        return summary
